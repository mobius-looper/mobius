<!DOCTYPE document>
<document>
<heading>
<title>Mobius Scripting</title>
<date>January 2011</date>
</heading>

<TOC/>

<!--==================================================================

  Introduction

====================================================================-->

<section><title>Introduction</title>

<p>Mobius provides a powerful feature called <i>scripting</i> that can
be used to add new functions or customize the behavior of Mobius to
match your looping style.  Some of the things that can be done with
scripts include:</p>

<ul>
<li>Perform several functions at exactly the same time 
with a single button press.</li>
<li>Perform different functions from the same button, depending 
on the current loop mode.</li>
<li>Perform a function while temporarily changing one or more of the 
preset parameters.</li>
<li>Perform a sequence of functions at musically useful intervals.</li>
<li>Automate gradual changes to output level and pan.</li>
</ul>

<p>A script is simply a text file that can be created with any text
editor.  The contents of the script file are statements in a language
called the <i>Mobius Scripting Language</i>.  Once the script files
have been written, they are <i>registered</i> so that Mobius knows
their names and locations.  Once a script file has been registered, it
may be assigned one or more <i>triggers</i> which can be MIDI messages,
computer keyboard presses, or buttons in the Mobius window.</p>

<p>When a trigger for a script is received, the statements in the
script are performed.  This process is called <i>running the
script</i>, <i>executing the script</i>, or <i>calling the
script</i>.</p>

<p>The following is an example of a simple script:</p>

<example>
  wait loop
  Reverse
  HalfSpeed
</example>

<p>When this script is called, it will first wait until the loop
reaches its start point, then perform a <i>Reverse</i> and 
<i>HalfSpeed</i> function at exactly the same time.</p>

</section> <!-- Introduction -->

<!--==================================================================

  Writing Scripts

====================================================================-->

<section><title>Writing Scripts</title>

<p>You may write a script using any text editor, though it is
critical that you save the files as "plain text".  If you are not
in the United States you need to be careful about the character
encoding used for the script file.  Scripts must be written in an
8-bit character encoding that is compatible with ASCII.</p>

<p>If you are using <i>Notepad</i> on Windows, you must
save the file using the <i>ANSI</i> encoding, you must <b>not</b>
use <i>Unicode</i>.  If you are using <i>Wordpad</i>, in 
the <i>Save as type:</i> menu you must select either <i>Text Document</i>
or <i>Text Document - MS-DOS Format</i>.</p>

<p>If you are using <i>TextEdit</i> on a Mac, you need to save the
file in a plain text encoding, either <i>Western (Mac OS Roman)</i>
or <i>Western (Windows Latin 1)</i>.  When you use the <i>Save As</i>
menu item, if you see a <i>File Format:</i> menu with items like
<i>Rich Text Format</i> or <i>Web Page (.html)</i> then you are editing
the file using rich text rather than plain text.   Open the TextEdit
Preferences window and under the <i>New Document</i> tab select 
the <i>Plain Text</i> radio button under the <i>Format</i> section.  Once
you do this create a new document and the <i>Save As</i> window should
show a <i>Plain Text Encoding:</i> menu, select <i>Western (Mac OS Roman)</i>.</p>

<p>There are many text editors available that present encoding options
in different ways or using different words.  The presentation may also be
different on different versions of the operating system.  The main thing
to keep in mind is that you must always pick the simplest text format 
available, usually this is referred to as "plain text" with encodings
such as "ansi", "latin 1", "roman", or "MS-DOS".  Stay away from anything
that says "rich" or "unicode" or that looks like a word processor format.</p>

<p>A script file may have any name, but it is recommended that they
have the extension <b>.mos</b>.  Scripts may be stored in any
directory.  On OS X most people keep them in
<i>/Library/Application Support/Mobius/scripts</i>.  On Windows
most people keep them in a directory under the Mobius installation
directory, usually <i>c:\Program Files\Mobius\scripts</i>.  </p>

<p>Once you have created the script file, you need to tell Mobius
about it through a process called <i>script registration</i>.  There
are two ways to register scripts: by file and by directory.  When you
register a script file, that file is loaded into Mobius when it
starts.  If you register a script directory, all scripts in that
directory are loaded.  Registering script directories is convenient if
you have a lot of scripts and you don't want to register all of them
one at a time.  You do need to be careful though to only put things in
this directory you really need.</p>

<p>To register a script open the <i>Configuration</i> menu and
select <i>Scripts</i>, the Script Registration window will open.</p>

<img alt='Graphic' src='images/starting-scripts-windows.gif'/>

<p>On Windows you will see <i>Add Script</i> and <i>Add Directory</i>
buttons that will bring up standard selection dialogs for files or
directories.  On Mac you will see a similar window but it will only
have a single <i>Add</i> button because the standard Mac file selector
lets you select both files and directories.</p>

<p>To register a new script or script directory, click one of the add buttons,
navigate to the file or directory you want to register and click <i>Open</i>
on Windows or <i>Choose</i> on Mac.   The name of the file or directory
should now appear in the list in the center of the script registration window.
If you want to remove an item from the list, click on it so that it
becomes highlighted then click the <i>Delete</i> button.  Finally
click the <i>Ok</i> button at the bottom of the widow to save
the changes.  The new set of scripts will be loaded into Mobius and
are available for binding.</p>

</section> <!-- Writing Scripts -->

<!--==================================================================

  Running Scripts

====================================================================-->

<section><title>Running Scripts</title>

<p>Like build-in functions, scripts are run in response to a
<b>trigger</b> such as a MIDI message, computer keyboard key, or a button
in the Mobius user interface.   The process of associating a trigger
with a script si called <b>binding</b>.  
>See the <a href='starting.htm#Controlling Mobius'>Controlling Mobius</a>
in the <i>Getting Started</i> manual for a full description of how
to create bindings. Once you
have registered some scripts or script directories you will start
seeing their names in the <i>Scripts</i> tab of the binding windows.</p>

<p>Note that scripts will usually appear in the binding windows with
a name other than the raw file name.  Most scripts include a line
starting with <i>!name</i> at the top that specifies a user friendly name
you want to see in the binding windows.  For example:</p>

<example>
    !name Global Fade Out
</example>

<p>A typical script file may have a name like "fadeoutall.mos" but the
name you see in the binding windows might be "Global Fade Out" or something
else more meaningful than the file name.  You will need to look in each
script to see if it contains a <i>!name</i> line and remember to look for
that name in the binding windows.  If the script doesn't have a <i>!name</i>
line you will just see the name of the script file without the ".mos" 
extension.</p>

<p>When binding a script to a trigger, consider whether you want
to use advanced script features such as <ref>Sustain Scripts</ref>
or <ref>Long Press Scripts</ref>.  These features require that the
script be bound to a 
<a href='starting.htm#Sustainable Trigger'>Sustainable Trigger</a>
such as a MIDI <i>note</i> message.</p>

</section> <!-- Running Scripts -->

<!--==================================================================

  Debugging Scripts

====================================================================-->

<section><title>Debugging Scripts</title>

<p>TODO: Introduce DBWIN32, Echo, Message, Prompt...</p>

</section>

<!--==================================================================

  Fundamentals

====================================================================-->

<section><title>Script Language Fundamentals</title>

<p>A script is simply a text file containing lines of characters with
each line ending with a return character.  Each line of text will be
one of the following types:</p>

<ul>
<li>Empty</li>
<li>Comment</li>
<li>Declaration</li>
<li>Statement</li>
</ul>

<p>For a given line of text the first <i>significant</i> character
determines the type.  The first significant character is anything
other than <i>white space</i> characters such as spaces and tabs.</p>

<p>If all the characters on a line are <i>white space</i>, the line is
<i>empty</i> and is ignored.</p>

<p>If the first significant character is a <b>#</b> the line
is a <i>comment</i> and the entire line is ignored.</p>

<p>If the first significant character is a <b>!</b> the line
is a <i>declaration</i>.</p>

<p>If the first significant character is anything other than whitespace,
<b>#</b> or <b>!</b> the line is a <i>statement</i>.</p>

<p>Declarations are used to give Mobius information about how
to run the script.  They can appear anywhere in the script but
it is recommended that you put them all at the top.  The order of
declarations is not important.</p>

<p>Statements are performed in the order they are written in the script.</p>

<p>This example script shows each of the line types.</p>

<example>
  # Do the NextLoop function after turning off switch quantize
  !name Next Loop Now

  set switchQuant off
  NextLoop
</example>


<p>The first line begins with a # so it is a comment.  You may put
comments anywhere in the script to explain what the script is doing.</p>

<p>The second line is a declaration, in this example it is specifying
the name you want to display in the binding windows.</p>

<p>The third line is empty.</p>

<p>The fourth and fifth lines are statements.</p>

<p><b>GEEK NOTE:</b>If you have experience with other programming
languages, note that Mobius does not support multi-line statements
(with or without a line continuation character) and there are no block
comments.  If you don't know what that means don't worry.  All that
you need to remember is that a comment, declaration or statement must
all be one one line.</p>

<section><title>Anatomy of a Statement</title>

<p>A statement always begins with a <i>Keyword</i> which is a sequence
of letters and numbers with no spaces.  Example keywords are
<i>Record</i>, <i>set</i>, and <i>if</i>.  When we talk about
statements, we usually identify them by their keyword, such as <i>"a
Record statement"</i> or <i>"an if statement"</i>.</p>

<p>After the keyword, a statement may contain <i>arguments</i> or
<i>expressions</i>.  An argument is a single word or number without
spaces, an expression is a complex sequence of characters that may
include spaces.  Consider this example:</p>

<example>
  variable nextLoop
</example>

<p>In the previous example the keyword is <i>Variable</i> so this
is called a <i>Variable statement</i>.  After the keyword
is the argument <i>nextLoop</i>.  The meaning of the argument
depends on the keyword, in this case the argument is the name
of a script variable.  Here is a more complex example:</p>

<example>
  variable nextLoop loopNumber + 2
</example>

<p>In a <i>variable</i> statement, all of the characters after
the name argument are an expression.  This expression is used
to calculate the initial value of the variable.  In this example
<i>loopNumber + 2</i> is the expression.</p>

<p>Some statements have no arguments, a few have more than one
argument.  Most statements will either zero or one expression.  When a
statement has both an argument and an expression, the argument comes
first.  In a few rare cases a statement may allow more than one
expression, if so the expressions must be seperated by a comma.</p>

</section> <!-- Anatomy -->

<section><title>Intrinsic and Function Statements</title>

<p>There are two categories of statements: those that are an intrinsic
part of the scripting language, and those that execute Mobius looping
functions.  Examples of intrinsic statements are <i>variable</i>,
<i>set</i>, <i>if</i> and <i>for</i>.  Examples of function statements 
are <i>Record</i>, <i>Overdub</i> and <i>NextLoop</i>.</p>

<p>The intrinsic statements do not change often, but new function
statements are added frequently.  All the Mobius functions that are
visible in the binding windows may be used in scripts, as well as
several special functions that are available only in scripts.
Whenever we talk about new functions being added to Mobius,
you can assume that these functions can also be used in scripts.</p>

<p><b>GEEK NOTE:</b>If you are familiar with the C language, you can
think of intrinsic statements as being similar to the core C language,
and the functions being similar to the "stdio.h" standard library.</p>

<p>All of the intrinsic statements will be described in detail 
because you need to understand all of them to write complex scripts.</p>

<p>The names of the function statements will not be listed here.  Instead
consult the <a href='reference.htm'>Mobius Reference</a> manual and find the
function you want to use, look for it's <b>Internal name</b>, and use
that internal name as the first word in the statement.</p>

</section> <!-- Intrinsics and Functions -->

<section><title>Case Insensitivity</title>

<p>The script language is <i>case insensntive</i> which means that
upper case and lower case letters are considered to be the same.  In
the examples you will see, function names usually start with a capital
letter and variable names start with a lowercase letter.  When a
function or variable name contains more than one word, a
capitalization style called "camel case" is used which means that the
initial letter of adjacent words are upper case and the other letters
are in lower case.  For example:</p>

<example>
  NextLoop
  variable saveQuantize quantize
</example>

<p>You do not have to follow this style, "NextLoop", "nextloop",
"NEXTLOOP", or "NeXtLoOp" all mean the same thing.</p>

<p>Intrinsic statements will begin with a lower case letter in this
document, but this is very inconsistent in older script examples.
Keywords whose names are found in common programming
languages are usually written in all lower case, these include
<i>if</i>, <i>else</i>, <i>for</i>, and <i>while</i>.  But other
Other keywords are often capatilized, such as
<i>Variable</i>, <i>Label</i>, and <i>Jump</i>.</p>

</section> <!-- Case Insensitivity -->

<section><title>Parameters and Variables</title>

<p>TODO: The difference between parameters and variables, User defined
and system variables, variable scoping...</p>

</section>

<section><title>Statement Blocks and Indentation</title>

<p>A few statements are used to define a range of statements
that may be executed more than once or not at all.   The range
of statements is called a <i>statement block</i>, the statements
that surround the block are called <i>block start</i> and <i>block end</i>
statements.</p>

<p>The following table lists the block start statements with their
corresponding block end statements:</p>

<table>
<tr><th>Start</th><th>End</th></tr>
<tr><td>if</td><td>endif, else, elseif</td></tr>
<tr><td>elseif</td><td>endif, else, elseif</td></tr>
<tr><td>else</td><td>endif</td></tr>
<tr><td>for</td><td>next</td></tr>
<tr><td>repeat</td><td>next</td></tr>
<tr><td>while</td><td>next</td></tr>
<tr><td>proc</td><td>endproc</td></tr>
</table>

<p>How the block statements behave will be described later.
The important thing to know now is that statement blocks must have
both a start and end statement and you must use the end statement that
is appropriate for the start statement.</p>

<p>Here are some examples of statement blocks:</p>

<example>
  if mode = record
    Overdub
  else
    Reset
  endif

  for *
    set 8thsPerCycle 8
  next
</example>

<p>To help make it clear where the statement blocks start and end
it is recommended that you use <i>indentation</i> for the lines
inside the block.  Most examples use 2 spaces of indentation but
you can use any number.  Indentation is not required but it makes
the script easier to read and understand.</p>

<p>Block statements may be <i>nested</i> which means that a block may
appear inside another block.  Here is a simple example of a nested block:</p>

<example>
  if mode = record
    if track = 1
      Overdub
    endif
  endif
</example>

<p>When blocks are nested, the block start statement is paired with
the nearest block end statement that follows.  It is strongly
recommended that you use indentation to make it clear which block
start and end statements belong together.</p>

</section> <!-- Blocks and Indentation -->

<section><title>The Mysterious $</title>

<p>The <b>$</b> is a special character used to indicate that the word
that follows it is a parameter or variable reference.  In early versions of
Mobius the $ was required for references, now it is optional
in most places.  Since it appears in example scripts it tends to keep
reappearing even though it is not required.</p>

<p>The $ is required in a few statements where it is not clear whether
a word is a reference, or simply a word.  These statements are:</p>

<ul>
<li>echo</li>
<li>message</li>
<li>prompt</li>
</ul>

<p>These functions all use the remainder of the line following the
keyword as a message to be displayed to the user.  The message will be
displayed exactly as it is written.  For example the statement
"message mode" will display the string "mode".  If you want to display
a message with the name of the current looping mode, you reference
the <i>mode</i> variable with a $.</p>

<example>
  message The current mode is $mode
</example>

</section>

</section> <!-- Script Language Basics -->

<!--==================================================================

  Execution Environment

====================================================================-->

<section><title>Script Execution Environment</title>

<p><b>NOTE</b>: This section introduces concepts that may be difficult
for people without programming experience to understand.  It is not
necessary to understand this section in order to write scripts.  But
if you write scripts using the <ref>wait</ref> statement, the
<ref>!sustain</ref> declaration, or the <ref>!multiclick</ref>
declaration, this section will help you understand how to get the most
power out of these features.</p>

<p>Scripts are similar to a re-entrant function in a multi-threaded
programming language.  These concepts should be familar to most
programmers, but they basically mean that there can be several copies
of the script running at the same time.</p>

<p>Each of the calls for the down transition, up
transition, and sustain notifications are done in an environment
similar to a thread.  If you use Wait statements, it is possible for
the script to be active in more than one thread.  By using variables,
the threads can communicate with each other.</p>

<p>More here...</p>

</section> <!-- Execution Environment -->

<!--==================================================================

  Reference

====================================================================-->

<section><title>Script Language Reference</title>

<!--==================================================================

  Declarations

====================================================================-->

<section><title>Declarations</title>

<p>In this section we will describe the declarations.  These may
appear anywhere in the script though there are usually written
at the top.</p>

<section><title>!autoload</title>

<p>Normally scripts are loaded once when Mobius is first started and
remain in memory for as long as Mobius runs.  If you make changes to
the script file they will not be used by Mobius until you restart it.</p>

<p>The <i>!autoload</i> declaration will cause the script file to be
reloaded from the file system every time the script is called.  
This is very useful when writing new scripts as it allows you to keep
Mobius running while you make changes the script.</p>

<p>After the script is working properly you should remove this
declaration.  Realoading the script causes a small delay before
the script is run.  This can make it difficult to apply the script
to exect locations in the loop.</p>

</section> <!-- autoload -->

<section><title>!controller</title>

<p>This option identifies the script as a <i>controller</i> script.
When the script is triggered by a MIDI continuous controller, the
script is called whenever the value of the controller changes.</p>

<p>Normally, when a script is bound to a MIDI continuous controller,
it is assumed that the controller messages are being sent by a momentary
switch rather than an expression pedal.  Momentary switches typically
send a non-zero controller value when the switch is pressed and a zero
value when the switch is released.  Mobius will only call the script
when it receives a non-zero value which means the switch has been 
pressed.  It will not call the script when it receives a zero value
after the switch is released, unless you also use the <ref>!sustain</ref>
declaration.</p>

<p>This behavior is usually not desired when the continuous controller
values are being generated by an expression pedal.  With an expression
pedal, you want the script called whenever the position of the pedal
changes, even when it goes to zero.</p>

<p>Controller scripts are most often used to change the 
<a href='reference.xml#Track Controls'>track controls</a>: 
<i>Input Level</i>,
<i>Output Level</i>,
<i>Feedback</i>,
<i>Secondary Feedback</i>, and
<i>Pan</i>.</p>

<p>They may also be used to change rate and pitch shift for each track,
and change preset paramters such as <i>8ths Per Cycle</i> or any other
parameter that has a range of values.</p>

<p>Including the <i>!controller</i> declaration in a script will
<b>disable</b> the following directives if they also appear in the script.</p>

<ul>
<li>!quantize</li>
<li>!switchQuantize</li>
<li>!sustain</li>
<li>!multiclick</li>
<li>!spread</li>
</ul>

<p>Here is an example script that implements a basic volume control.
The behavior of this scipt is exactly the same as binding
a controller to the <i>Output Level</i> track control.</p>

<example>
  !name Output Level
  !controller
  set outut midiValue
</example>

<p>The <i>!controller</i> declaration tells Mobius that this script
should be called every time the value of the trigger changes.  The
word <i>midiValue</i> is a reference to a system variable that will
contain the value of the continuous controller that triggered this
script. The value will be from 0 to 127.</p>

<p>Here is a more interesting example that sets the output level
to the inverse of the controller value. When the controller
value is zero (toe up) the output level will be 127, when the
controller value is 127 (toe down) the output level will be zero.</p>

<example>
  !name Backwards Output Level
  !controller
  set output 127 - midiValue
</example>

<p>If you are familar with the EDP, controller scripts give you the
ability to implement "flip mode" as well as many other combinations of
Mobius controls that change in response to a single expression pedal.</p>

</section> <!-- !controller -->

<section><title>!focuslock</title>

<p>Normally scripts do not obey focus lock or track groups.  When a
script is run it will only run in the selected track.</p>

<p>The <i>!focuslock</i> declaration makes the script sensitive to
track focus lock.  The script will be run simultaneously in all focused
locked tracks.  If the <a href='reference.htm#Groups Have Focus Lock'>Groups Have Focus Lock</a> parameter is true, this declaration will also cause the script to be run in all tracks that have the same group as the selected track.</p>

<p>This option is useful for simple scripts that only operate
on one track.  It makes the script behave more like the built-in
Mobius functions.  If however the script uses the <ref>for</ref> 
statement to operate on several tracks, you normally do not
use the <i>!focuslock</i> option.</p>

</section> <!-- focuslock -->

<section><title>!multiclick</title>

<p>This option allows the script to change behavior if you trigger it
more than once within a short time.  Some people think of this as
"double clicking".  A script that uses this option is called a
<i>multi-click script</i>.</p>

<p>To create a multi-click script, add this declaration:</p>

<example>
  !multiclick 2000
</example>

<p>The numeric argument is the <i>trigger expiration period</i>
expressed as a number of milliseconds.  The default expiration period
is 1000 (1 second) so you only need to include this argument if you
want a value other than 1000.  In this example the expiration
period will be two seconds.</p>

<p>Next add <i>Label</i> statements to the script with these names:</p>

<ul>
<li><b>click</b> - run whenever the script is triggered again 
before the expiration period</li>
<li><b>endClick</b> - run when the trigger expiration period is reached</li>
</ul>

<p>As always this is best described with an example:</p>

<example>
  !name Multiclick Test

  # the default value is 1000 milliseconds, override to 2 seconds
  !multiclick 2000

  message Starting Click Test
  end

  label click
  message Click $clickCount
  end

  label endClick
  message Ending Click Test
  end
</example>

<p>When you trigger the script for the first time, the message
"Starting Click Test" is displayed. If you trigger the script again
within 2 seconds, a message is displayed showing the number of
triggers that have been received from the system variable
<i>clickCount</i>.  If you wait 2 seconds without triggering the
script again, the "Ending Click Test" message is displayed and the
script is finished.</p>

<p>Each time the script is triggered, the expiration period starts
over at 2 seconds.</p>

<p><b>GEEK Note</b>: As with sustain scripts, the <i>click</i> and 
<i>endClick</i> labels are called in different threads so the script
may be active in more than one thread.  Variables can be used for communication 
between threads.</p>

</section> <!-- multiclick -->

<section><title>!name</title>

<p>This declaration is used to specify the name to be displayed for
this script in the binding windows.  If no name is specified, the file
name is displayed.  It is very common to use a <i>!name</i>
declaration since the script file name is not always meaningful to the
user.</p>

<p>The name consists of all characters after the space after the
<i>!name</i> declaration up to the end of the line.  In the following
example, the name displayed for the script would be "Auto Record 4".</p>

<example>
  !name Auto Record 4
</example>

<p>Like all declarations, <i>!name</i> may appear anywhere in the file
but it is usually the first line to make it easier to see.</p>

</section> <!-- name  -->

<section><title>!quantize</title>

<p>Normally scripts will not obey the 
<a href='reference.htm#Quantize'>Quantize Mode</a> parameter in the preset.
When a script is triggered it will be run immeidately.</p>

<p>The <i>!quantize</i> option makes the script sensitive to the
<a href='reference.htm#Quantize'>Quantize Mode</a> parameter, 
it will be run at the next quantization point.
This makes scripts behave more like built-in functions.</p>

<p>This option is most often used when the script does not begin
with a <i>Wait</i> statement.</p>

<p>TODO: The difference between !quantize and Wait...</p>

</section> <!-- quantize -->

<section><title>!spread</title>

<!-- xxx unedited -->

<p>This option will allow the script to be triggered by a range of
MIDI <i>note</i>, <i>controller</i>, or <i>program change</i> messages.
The script is bound once to the center of the range, but will then be
triggered by messages on either side of the center.</p>

<p>This option is usually used when binding to MIDI <i>note</i> messages.  If
the script is bound to middle C, then notes on either side of middle C
will automatically be bound to the script.  This is similar to the way
the <i>Pitch Shift</i> and <i>Rate Shift</i> functions behave.  The
note you select in the binding window is the center note, pressing
notes below the center lowers the pitch/rate, pressing notes above the
center raises the pitch/rate.</p>

<p>For spread scripts, the script will be run when any note in the
range is pressed.  The script can then reference internal variables to
determine which note within the range was pressed.</p>

<p>While it will be most common to bind spread scripts to MIDI notes
so that you can "play" the script chromatically, you can also bind the
script to a range of program changes or continuous controller
values.</p>

<p>To define a spread script, include this declaration at the top:</p>

<example>
  !spread
</example>

<p>The default range of the spread is 48 values on either side of the
center, which for notes means 4 octaves up and 4 octaves down. You can
reduce this range by adding an argument to the <i>!spread</i> declaration:</p>

<example>
  !spread 4
</example>

<p>In the previous example, the 4 argument means that the spread will
be 4 notes on either side of the center.</p>

<p>If there is a conflict between a spread script binding and another
function that is bound to a specific note, the other function will
have priority.  For example, if a spread script with a range of 12 is
bound to note 64, the script will be called whenever notes 52 to 76
are received. If you also have the Record function bound to note 59,
that note will call the Record function, but all the notes around it
will still call the script.  You can think of this like "holes being
punched" into the spread range.  You usually do not want to have a
spread range conflict with another function binding so it is best to
move the center notes so they do not overlap. If you want to have a
large spread range, you will need to use different MIDI channels for
the center notes.</p>

<p>When a spread script is called, the following system variables may
be referenced to adjust the behavior of the script:</p>

<ul>
<li><b>triggerOffset</b> - A positive or negative integer representing the
relative position of the trigger from the center of the range.</li>
</ul>

<p>For example, if you bind the script to note 64 and you press note
63, the value of <i>triggerOffset</i> will be -1. If you press note 64
<i>triggerOffset</i> will be 0, and if you press note 65 <i>triggerOffset</i>
will be 1.</p>

<p>The built-in Rate Shift function could be implemented with
this script:</p>

<example>
  !name Script Rate Shift
  !spread 12
  RateShift triggerOffset
</example>

<p>Spread scripts are probably most useful with the RateShift, PitchShift,
LoopTrigger, and TrackSelect functions. But you could also use them
to set the ouput level or 8thsPerCycle parameter.</p>

<p>As a more interesting example, if you always want to rate shift
in octave intervals, you could use this script and you would only need
to reserve 9 notes:</p>

<example>
  !name Rate Shift Octaves
  !spread 4
  RateShift triggerOffset * 12
</example>

</section> <!-- !spread -->

<section><title>!sustain</title>

<p>This option will cause the script to be run on both the <i>down</i>
and <i>up</i> transitions of the trigger.  A down transition happens when
you press a switch, an up transition happens when you release a switch.
A script that uses this option is called a <i>sustain script</i>.  Sustain
scripts are effective only if you are using a momentary trigger such
as a MIDI note, MIDI continuous controller, or computer keyboard key.</p>

<p>To use MIDI notes, the trigger device must send a <i>Note On</i>
event when a switch is pressed and a <i>Note Off</i> event when the
switch is released.  To use MIDI continuous controllers, the switch
must send a CC value greater than zero when the switch is pressed and
zero when the switch is released.  Note that you can not use MIDI
program changes for sustain scripts since the program change is only
sent when the switch is pressed.</p>

<p>Sustain scripts are also run repeatedly while the switch is held
down, this allows it to change behavior depending on how long the
switch is held.  This allows scripts to have <i>long press</i>
behavior like other built-in functions.</p>

<p>To be notified when the trigger goes up, you simply add this
label to the script:</p>

<example>
  label endSustain
</example>

<p>The statements following this label will be run when the function
trigger goes up.</p>

<p>To be notified while the trigger is held, add this label to the script:
</p>

<example>
  label sustain
</example>

<p>The statements following this label will be run every 250 milliseconds
(1/4 second) while the trigger is held. You can determine how
long the trigger has been held by testing the <i>sustainCount</i> variable.
This will have a number starting at 1 and incrementing by 1 every time
the sustain script is called.</p>

<p>You can specify the duration of the sustain notifications by adding
a number after the !sustain keyword.   This number is the number of
milliseconds between notifications.  For example, this declaration
will cause the sustain label to called every second rather than every 
1/4 second.</p>

<example>
  !sustain 1000
</example>

<p>Here is a more complex example that demonstrates all of the features
of sustain scripts.</p>

<example>
  !name Sustain Test

  # default is 250 msec, raise it to 1 sec
  !sustain 1000

  # the Message statement can be used to display brief messages
  message Starting sustain test
  end

  label sustain
  message Sustained $sustainCount
  end

  label endSustain
  message Ending sustain test
  end
</example>

<p>You can think of this as 3 scripts in one. From the top to the first
<i>end</i> are the statements that are run when the switch is pressed.</p>

<p>The statements from <i>label sustain</i> to the next <i>end</i> are 
called as the switch is held.</p>

<p>The statements from <i>label endSustain</i> to the next <i>end</i> 
are called when the function trigger goes up.</p>

<p>You do not need to declare both labels, but you do need to remember
to put an <i>end</i> before each of the sustain lables.</p>

<p><b>GEEK Note</b>: Scripts are similar to a re-entrant function in a
multi-threaded programming language.  Each of the calls for the down
transition, up transition, and sustain notifications are done in an
environment similar to a thread.  If you use Wait statements, it is
possible for the script to be active in more than one thread.  By
using variables, the threads can communicate with each other.</p>

<p>Here is a more realistic example. A long-press of the Record function
will normally perform a Reset. This script does something similar but
with the Mute function.</p>

<example>
  !name Mute/Reset

  Mute
  end

  label sustain
  if sustainCount = 1
  Reset
  endif
</example>

<p>Under the <i>sustain</i> label, you can test the
<i>sustainCount</i> variable to make the script change behavior the
longer the trigger is held.  Some examples of this might be:</p>

<ul>
<li>change rate or pitch shift the longer the trigger is held</li>
<li>bounce between half speed and normal speed every second as long as the trigger is held</li>
<li>slip forward one subcycle every 1/2 second</li>
</ul>

<p>Here is another example of simle sustain sccript that raises the
rate a fifth while held and drops it back when released.</p>

<example>
  !name SUSRateUp5

  RateUp 7
  end

  label endSustain
  RateDown 7
  end
</example>

</section> <!-- sustain -->

<section><title>!switchQuantize</title>

<p>When you change loops with the <i>switchQantize</i> parameter
set something other than <i>off</i>, Mobius will enter a special
<i>Switch</i> mode while it waits for the next 
switch quantization point.  During this mode, many functions that
you trigger are queued and performed after the loop switch.</p>

<p>By default scripts do not wait until after the loop switch, 
they are run immediately.  The <i>!switchQuanitze</i> option
will delay the execution of the script until after the loop switch.
This makes scripts behave more like built-in functions.</p>

<p>Note however that the functions performed by the script are not
treated like alternate endings to the switch function.  For example,
if you do an Overdub during the switch quantization and the next
loop is empty, the current loop is copied into the next loop.  But
if you run a script whos first function is Overdub, this will
not cause the loop to be copied.</p>

</section> <!-- switchQuantize -->

</section> <!-- Declarations -->

<!--==================================================================

  Expressions

====================================================================-->

<section><title>Expressions</title>

</section> <!-- Expressions -->

<!--==================================================================

  Statements

====================================================================-->

<section><title>Intrinsic Statements</title>

<p>The syntax for each statement will be summarized using a notation
that programmers should recognize as similar to BNF.  For example:</p>

<pre>
    call &lt;scriptName> | &lt;procName> [&lt;arg> ...]
</pre>

<p>A line in a script is divided into <i>tokens</i> seperated by one or
more spaces.  The syntax notation describes what each token means.
Tokens are often just words without spaces like <i>call</i>.  If
a token needs to contain spaces it must be surrounded in double
quotes like <i>"My Script"</i>.</p>

<p>In the syntax notation, tokens that are not surrounded by angle
brackets must be written exactly as shown.  Tokens that are
surrounded by angle brackets must be replaced with tokens that are
meaningful for your environment.  For example the token
<i>&lt;scriptName></i> would be replaced by the name of the script you
want to call.</p>

<p>The vertical bar is used when there is a choice of several tokens
that may apepar at this location.  In this example the token following
the <i>Call</i> may be either a procedure name or a script name.</p>

<p>Square brackets are used to surround optional tokens.  In this
example the <i>call</i> statement may have an optional list of
arguments.  The <i>...</i> means that the contents within the brackets
may be repeated any number of times.</p>

<p>Two special tokens are used in syntax notation:</p>

<ul>
<li><b>&lt;arg></b> - replaced by a symbol, string, or variable reference</li>
<li><b>&lt;expression></b> - replaced by a complex expression</li>
</ul>

<p>Note that some of the intrinsic statements are intended for use
only in special testing scripts.  The statement keywords are presented
using the character case that is most often seen in the example
scripts.  As mentioned in the <ref>Case Insensitivity</ref> section,
case in function names is ignored.</p>

<section><title>break</title>

<p>This statement is used only by developers running Mobius under a
debugger.  It will have no effect when running Mobius outside of a
debugger.  Return to your homes, there is nothign to see here.</p>

</section>

<section><title>call</title>

<pre>
    call &lt;scriptName> | &lt;procName> [&lt;arg> ...]
</pre>

<p>Calls another script or a <i>procedure</i>, with optional arguments.</p>

<p>When a script is called, the statements in the script are executed
as if they were written directly in the calling script.  Only scripts
that have been registered in the <i>Scripts</i> dialog can be
called.</p>

<p>Normally scripts are referenced using the name defined by the
<i>!name</i> declaration in the script.  If the script has no
<i>!name</i> you may reference the script using its file name.</p>

<example>
  # Call a script using its !name
  # note that quotes must be used if the script name contains spaces

  call "My Script" 

  # Call a script using its file name
  call myscript.mos

  # Call a script using its file name without the .mos extension
  call myscript
</example>

<p>Script arguments may either be symbols, strings, or variable
references.  A symbol is simply a word without spaces.  A string is a
sequence of characters surrounded by double quotes.  A variable
reference is the name of a variable or parameter prefixed with the
<b>$</b> character.</p>

<example>
  # Call a script passing a symbol argument
  call "Set Sub Cycles" 8

  # Call a script passing a string argument
  call ShowMessage "This is my message to you!"

  # Call a script passing a variable value
  variable message "This is my message to you!"
  call ShowMessage $message
</example>

<p>In the script being called, arguments are referenced with 
a number preceeded by the $ character.  Script arguments are numbered
starting from 1.  For example:</p>

<example>
  !name Set Sub Cycles
  message Changing subcycles to $1
  set 8thsPerCycle $1
</example>

<p>The previous script will set the <i>8thsPerCycle</i> preset parameter
to the value of the first argument.</p>

<p>Note that scripts that are designed to be called from other scripts
usually do not have any declarations other than <ref>!name</ref> and
sometimes <ref>!autoload</ref>.  Any other declarations in the called
script will be ignored.  If you want the called script to be quantized
for example, you will need to use the <ref>wait</ref> statement
in the calling script.</p>

<section><title>Procedures</title>

<p>A procedure is a set of statements defined within a script that
will not be executed until you call them.  Procedures are defined with
the <ref>proc</ref> statement.  Procedures are used in the Mobius test
scripts but are not often used in user scripts.  Their primary use is
to prevent the duplication of a set of statements that are needed more
than once in the script.</p>

<example>

  # define a procedure
  # the statements within the Proc/Endproc will NOT be executed
  # until you call the procedure

  # Define a procedure
  proc ChangeDirection
    if inReverse
        Message Leaving reverse mode
    else
        Message Entering reverse mode
    endif
    Reverse
  endproc

  # toggle reverse mode with a message
  call ChangeDirection

  # wait for the end of the loop
  wait loop

  # toggle reverse mode with a message again
  call ChangeDirection
</example>

<p>Arguments may also be passed to called procedures:</p>

<example>
  # set 8thsPerCycle to the value of the first argument
  proc SetSubCycles
    set 8thsPerCycle $1
  endproc

  # call procedure passing number of subcycles desired
  call SetSubCycles 8
</example>

</section> <!-- Procedures -->

</section> <!-- call -->

<section><title>cancel</title>

</section>

<section><title>diff</title>
</section>
<section><title>end</title>
</section>
<section><title>endproc</title>
</section>
<section><title>echo</title>
</section>
<section><title>else</title>
</section>
<section><title>elseif</title>
</section>
<section><title>endif</title>
</section>
<section><title>end</title>
</section>
<section><title>for</title>
</section>
<section><title>if</title>
</section>
<section><title>initpreset</title>
</section>
<section><title>jump</title>
</section>
<section><title>label</title>
</section>
<section><title>load</title>
</section>
<section><title>message</title>
</section>
<section><title>next</title>
</section>
<section><title>preset</title>
</section>
<section><title>proc</title>

<pre>
    proc &lt;procedureName>
</pre>

<p>This statement begins a procedure definition.  The argument must be
a literal string that defnes the procedure name.  The procedure definition
must be terminated by an <ref>endproc</ref> statement.</p>

<p>See <ref>Procedures</ref> for more infomration on defining and calling procedures.</p>

</section>

<section><title>prompt</title>
</section>
<section><title>repeat</title>
</section>
<section><title>save</title>
</section>
<section><title>set</title>
</section>
<section><title>setup</title>
</section>
<section><title>unittestsetup</title>
</section>
<section><title>variable</title>
</section>
<section><title>wait</title>
</section>
<section><title>while</title>
</section>

</section> <!-- Intrinsic Statements -->

<!--==================================================================

  Labels

====================================================================-->

<section><title>Special Labels</title>

<section><title>reentry</title>
</section>

<section><title>sustain</title>
</section>

<section><title>endSustain</title>
</section>

<section><title>click</title>
</section>

<section><title>endClick</title>
</section>

</section> <!-- Special Labels -->

<!--==================================================================

  Functions

====================================================================-->

<section><title>Functions</title>

<p>All Mobius functions may be used in scripts.  The names of the
functions used in scripts may differ slightly from the names you will
see in the UI.  In particular, script function names never contain
spaces.  If a function name is displayed in the UI with spaces such as
"Next Loop", the script function name is usually the same with the
spaces removed such as "NextLoop".</p>

<p>The <a href='reference.htm#Functions'>function reference</a>
section of the <i>Mobius Reference</i> manual contains a complete
list of all functions arranged in alphabetical order by the
display name you will see in the UI.  Within the documentation
for each function will be a line beginning with <b>Internal name:</b>,
the word after this prefix is the name you would use in a script
to execute this function.</p>

<p>Note that the function names displayed in the UI are taken from a file that
may be modified by the user.  This file is called a <i>message catalog</i>.
The default message catalog is in the Mobius installation directory 
and is named <i>Catalog_USEnglish.txt</i>.  If you have modified this file,
or if you have asked Mobius to read messages from a different file, the
names that appear in the reference manual may not be the same as
what you will see in the UI.</p>

<p>We will not provide reference documenation for every function in
this manual.  We will only document functions and function features
that are only accessible from scripts.  For more information on
what the functions do and how they are influenced by parameters,
you must read the documentation in the reference manual.</p>

<section><title>Divide</title>

<p>The function named just <i>Divide</i> without a number is
accessible only scripts.  With this function the divisor is
specified as an argument written after the function name.  The argument
may be a number or an expression.  For example:</p>

<pre>
    Divide 6
    Divide subcycles / 2
</pre>

<p>In scripts you can also use the <i>Divide</i> functions that have
a fixed divisor in the function name.  These two script statements will have
the same effect.</p>

<pre>
    # here the divisor is part of the function name
    Divide4

    # here the divisor is an argument
    Divide 4
</pre>

<p>See <a href='reference.htm#Divide'>Divide</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Divide -->

<section><title>Backward</title>

<p><i>Backward</i> forces the loop direction into reverse and sets
the <i>Reverse</i> minor mode.  This function is
provided as a convenience for script writers 
that need to ensure the loop is playing backward without having
to test the <ref>inReverse</ref> variable.  The following
two code blocks have the same behavior.</p>

<pre>
    # Force reverse playback
    Backward

    # Toggle reverse if we're not already in reverse
    if !inReverse
       Reverse
    endif
</pre>

<p>See <a href='reference.htm#Backward'>Backward</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Backward -->

<!-- TODO: Bounce needs arguments for specifying the destination -->

<section><title>Forward</title>

<p><i>Forward</i> forces the loop into the normal forward
direction.  It is provided as a convenience for script writers that
need to ensure the loop is playing forward without having to 
test the <ref>inReverse</ref> variable.  The following two code
blocks have the same behavior.</p>

<pre>
    # Force normal playback
    Forward

    # Toggle reverse if we're currently in reverse
    if inReverse
       Reverse
    endif
</pre>

<p>See <a href='reference.htm#Forward'>Forward</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Forward -->

<section><title>FullSpeed</title>

<p><i>Full Speed</i> forces the loop out of
<i>1/2 Speed</i> minor mode.  If the loop is not in
<i>1/2 Speed</i> mode, the function will have no effect.  This is provided
as a convenience to script writers that need to ensure the loop is
playing at normal speed withing having to test the <ref>inHalfSpeed</ref>
variable.  The following two code blocks have the same behavior.</p>

<pre>
    # Force normal playback
    FullSpeed

    # Toggle speed if we're currently in 1/2 speed
    if inHalfSpeed
       Speed
    endif
</pre>

<p>See <a href='reference.htm#Full Speed'>Full Speed</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- FullSpeed -->

<section><title>HalfSpeed</title>

<p><i>Half Speed</i> forces the loop into 
<i>1/2 Speed</i> minor mode.  If the
loop is already in <i>1/2 Speed</i> mode the function has no effect.
This is provided as a convenience to script writers that need to ensure
the loop is playing at normal speed withing having to test the
<ref>inHalfSpeed</ref> variable.  
The following two code blocks have the same behavior.</p>

<pre>
    # Force 1/2 speed playback
    HalfSpeed

    # Toggle speed if we're not currently in 1/2 speed
    if !inHalfSpeed
       Speed
    endif
</pre>

<p>See <a href='reference.htm#Half Speed'>Half Speed</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- FullSpeed -->

<section><title>InstantMultiply</title>

<p>The function with internal name <i>InstantMultiply</i> without
a number may only be used in scripts.  The multiplier is specified as
an argument to the function.  For example:</p>

<pre>
    InstantMultiply 6
</pre>

<p>You can also use the <i>InstantMultiply</i> functions with numbers
in their names in scripts.  These two script statements will have the 
same effect.</p>

<pre>
    # here the multiplier is part of the function name
    InstantMultiply4

    # here the multiplier is an argument
    InstantMultiply 4
</pre>

<p>See <a href='reference.htm#Instant Multiply'>Instant Multiply</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- InstantMultiply -->

<section><title>Loop</title>

<p>The function named just <i>Loop</i> without a number is accessible
only in scripts.  With this function the loop you want to trigger
is specified as a function argument, which may be a number or an expression.
For example:</p>

<pre>
   Loop 3
   Loop loopNumber + 1
</pre>

<p>Scripts can also use the <i>Loop</i> functions with numbers in their
names.  These two script statements are the same.</p>

<pre>
   Loop4
   Loop 4
</pre>

<p>See <a href='reference.htm#Loop'>Loop</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Loop -->

<section><title>MidiOut</title>

<p><i>MidiOut</i> can send any MIDI message to the configured
MIDI output device.  This function is accessible only from scripts.
The MIDI message to send is specified with up to four function arguments.
The syntax is:</p>

<pre>
    MidiOut &lt;status> &lt;channel> &lt;value> &lt;velocity>
    status: noteon noteoff control program stop start continue
    channel: 0-15
    value: 0-127
    velocity: 0-127
</pre>

<p>For example, to send a <i>Note On</i> event on channel 3,
note 64, velocity 127, you would write:</p>

<pre>
    MidiOut noteon 3 64 127
</pre>

<p>This function does not change the current loop and has 
no effect on major or minor modes.</p>

</section> <!-- MidiOut -->

<section><title>Move</title>

<p><i>Move</i> will instantly move the loop playback position to a new
location.  It is accessible only from scripts.  The new position is
specified as a function argument which may either be a number or
an expression whose result is a number.  This number is used as 
a frame number within the loop.  The first frame in a loop has
frame number zero.</p>

<pre>
   # Jump to a fixed location 1 second from the beginning
   Move 44100

   # Jump to the center of the loop
   Move loopFrames / 2
</pre>

<p>See <a href='reference.htm#Move'>Move</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Move -->

<section><title>MuteOff</title>

<p><i>MuteOff</i> will cancel the <i>Mute</i> minor mode.  
If the loop is not in mute mode the function has no
effect.  This function is not quantized and is accessible only in scripts.
It is a convenience for script writers that want to make sure that mute mode
is off without having to worry about the current mute state.  You can
also use the <i>Mute</i> function but since that toggles mute mode you 
have to test the current mute state.  The following script examples are
equivalent:</p>

<pre>
    # Force mute off, ignore if it is already off
    MuteOff

    # Toggle mute off if it is currently on
    if inMute
       Mute
    endif
</pre>

<p>See <a href='reference.htm#MuteOff'>MuteOff</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- MuteOff -->

<section><title>MuteOn</title>

<p><i>MuteOn</i> will activate the <i>Mute</i>
minor mode and immediately silence the loop.  If the loop is already muted
the function has no effect.  This function is not quantized and is accessible 
only in scripts.   It is a convenience for script writers that want
to make sure that the loop is muted without having to worry about the
current mute state.  You can also use the <i>Mute</i> function but since that
toggles mute mode you have to test the current mute state.  The
following script examples are equivalent:</p>

<pre>
    # Force mute on, ignore if it is already on
    MuteOn

    # Toggle mute on if it is currently off
    if !inMute
       Mute
    endif
</pre>

<p>See <a href='reference.htm#MuteOn'>MuteOn</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- MuteOn -->

<section><title>OverdubOff</title>

<p><i>OverdubOff</i> forces the <i>Overdub</i> minor
mode off.  This function is not quantized and is accessible only
scripts.  It is provided as a convenience for the script writer that  needs
to turn overdub off, but is more convenient than using the <i>Overdub</i>
function that toggles overdub mode.  The following two script
examples are equivalent:</p>

<pre>
    # Force overdub off
    OverdubOff

    # Toggle overdub off if it is on
    if inOverdub
       Overdub
    endif
</pre>

<p>See <a href='reference.htm#OverdubOff'>OverdubOff</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- OverdubOff -->

<section><title>OverdubOn</title>

<p><i>OverdubOn</i> activates the <i>Overdub</i>
minor mode.  If overdub mode is already active the function has no effect.
This function is not quantized and is accessible only in scripts.
It is a convenience for the script writer that needs
to turn overdub on, but is more convenient than using the <i>Overdub</i>
function that toggles overdub mode.  The following two script
examples are equivalent:</p>

<pre>
    # Force overdub on
    OverdubOn

    # Toggle overdub on if it is off
    if !inOverdub
       Overdub
    endif
</pre>

<p>See <a href='reference.htm#OverdubOn'>OverdubOn</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- OverdubOn -->

<section><title>PitchShift</title>

<p><i>PitchShift</i> can change the pitch of the loop up or down by
any number of semitones.  When used in a script, the amount of
shift is specified as an argument to the function.</p>

<pre>
   PitchShift 5
   PitchShift -7
</pre>

<p>See <a href='reference.htm#Pitch Shift'>Pitch Shift</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- PitchShift -->

<section><title>RateShift</title>

<p><i>Rate Shift</i> can change the playback rate of the loop up or
down to achieve a pitch change in any number of semitones.  When used
in a script, the amount of shift is specified as an argument to the
function.</p>

<pre>
   RateShift 5
   RateShift -7
</pre>

<p>See <a href='reference.htm#Rate Shift'>Rate Shift</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- RateShift -->

<section><title>Sample</title>

<p>The <i>Sample</i> family of functions will play one of the loaded
samples.  The function named just <i>Sample</i> without a number may only
be used in scripts.  The sample to trigger is specified
as a function argument that may be a number or an expression.</p>

<pre>
   # trigger the first sample
   Sample1

   # another way to trigger the first sample with the number
   # specified as a function argument
   Sample 1
</pre>

<p>See <a href='reference.htm#Sample'>Sample</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Sample -->

<section><title>Shuffle</title>

<!-- TODO: Insert docs on complex shuffle patterns -->

</section> <!-- Shuffle -->

<section><title>Slip</title>

<p>The <i>Slip</i> family of functions will instantly move the loop
playback position forward or backward by a fixed amount.  The amount
of slippage for the <i>Slip</i> script function is specified as an
argument.  The value is a positive or negative number or an expression
that evaluates to a number.  This number is the number of 'units' to
slip where the unit is defined by the 
<a href='reference.htm#Slip Mode'>Slip Mode</a> parameter.</p>

<pre>
   # slip forward 2 cycles
   set slipMode cycle
   Slip 2

   # slip backward four subcycles
   set slipMode subcycle
   Slip -4
</pre>

<p>See <a href='reference.htm#Slip'>Slip</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Slip -->

<section><title>Sustain Functions</title>

<p>Explain how sustain functions can be used in scripts with the
up/down arguments.</p>

</section> <!-- Sustain Functions -->

<section><title>Track</title>

<p>The <i>Track</i> family of functions will activate one of the
numbered tracks.  If the track is already active, the function
will have no effect.  The function named just <i>Track</i> can only
be used in scripts where the track to select is specified as a function
argument.</p>

<pre>
   # Select a track using a numbered function
   Track2

   # Select a track using an argument
   Track 2

   # Select a track using an expression
   Track rand(1,8)
</pre>

<p>See <a href='reference.htm#Track'>Track</a> in the
<i>Mobius Reference</i> manual for more information.</p>

</section> <!-- Track -->

</section> <!-- Functions -->

<!-- ======================================================================

  Parameters

====================================================================== -->

<section><title>Parameters</title>

<p>Describe in general how parameters can be accesssed and set from
scripts..</p>

<section><title>Comma Separated Values</title>

<p>When a parameter value is described as being a "comma separated
list" it means that the value to assign in a set statement consists of
a list of words seperated by a comma.  There may also be spaces before
and after the commas.  The following examples are all the same:</p>

<example>
  set altFeedbackDisable Multiply,Overdub

  set altFeedbackDisable Multiply, Overdub

  set altFeedbackDisable Multiply  ,  Overdub
</example>

</section> <!-- Comma Separated Values -->

</section> <!-- Parameters -->

<!-- ======================================================================

  Track Parameters

====================================================================== -->

<section><title>Track Parameters</title>

<p>Each track has a few parameters that are set in the <i>Track
Setup</i>.  These will have their initial values specified in
the <i>Track Setup</i> but they may be changed in scripts.</p>

<section><title id='trackParameterFocus'>focus</title>

<p><b>Value value:</b> true, false</p>

<p>This parameter determines whether the track has <i>focus lock</i>.
The parameter may be set with the <i>Focus Lock</i> function or by clicking
on the <a href='exploring.htm#trackNumberStrip'>Track Number</a> 
in the track strip.</p>

<p><b>Script example:</b></p>
<pre>
    set focus true
    FocusLock 
</pre>

</section> <!-- Focus -->

<section><title id='trackParameterGroup'>group</title>

<p><b>Value:</b> an integer from 1 to 8</p>

<p>This parameter determines whether the track is a member of a track group.
The value is an integer parameter that has the number of the track group
in the current track.  If the value is zero there is no track group.
Positive group numbers are displayed as letters in the user interface.
Group 1 is displayed as <i>A</i> group 2 is displayed as <i>B</i>
etc.  When setting this parameter from a script you may use either numbers
staring from 1 or letters starting from A.</p>

<p><b>Script example:</b></p>
<pre>
    set group 1
    set group A
</pre>

</section> <!-- Group -->

<section><title id='trackParameterPreset'>preset</title>

<p><b>Value:</b> a preset name</p>

<p>This parameter has the name of the preset that is active in the
track.  This is intended for use only in scripts, in the user interface
you select presets from the <a href='starting.htm#presetmenu'>preset menu</a>
or from the <a href='starting.htm#Preset Window'>preset window.</a></p>

<p>When setting this from scripts you may use either the preset name
or the preset number from 1.  While setting this parameter in scripts
is allowed, it is preferable in scripts to use the <i>Preset</i>
built-in script function.</p>

<p><b>Script example:</b></p>
<pre>
    set preset 1
    set preset "My Preset"
    Preset 1
    Preset "My Preset"
</pre>

</section> <!-- TrackPreset -->

<section><title id='trackParameterPresetNumber'>presetNumber</title>

<p><b>Value:</b> an integer from 1 to infinity</p>

<p>This parameter has the number of the preset that is active in the
track.  This is intended for use only in scripts, in the user interface
you select presets from the <a href='starting.htm#presetmenu'>preset menu</a>
or from the <a href='starting.htm#Preset Window'>preset window.</a></p>

<p>When setting this from scripts you may use either the preset name
or the preset number from 1.  While setting this parameter in scripts
is allowed, it is preferable in scripts to use the <i>Preset</i>
built-in script function.</p>

<p><b>Script example:</b></p>
<pre>
    set presetNumber 1
    Preset 1
</pre>

<p>The parameter is functionally the same as 
<ref id='trackParameterPreset'>Preset</ref> but 
using it makes it clearer in the script that the value will be a number
rather than a name.</p>

</section> <!-- Preset Number -->

</section> <!-- Track Parameters -->

<!-- ======================================================================

  Track Controls

====================================================================== -->

<section><title>Track Controls</title>

<p>Examples of setting track controls from scripts.</p>

</section>

<!-- ======================================================================

  Variables

====================================================================== -->

<section><title>Variables</title>

<section><title>Script State</title>

<section><title>clickCount</title>
<p>Number of times the script has been reentred due to multi-clicks.</p>
</section>

<section><title>midiChannel</title>
<p>The MIDI channel number of the trigger event.
This is also embedded in triggerNumber, but it is easier to use here.</p>
</section>

<section><title>midiNumber</title>
<p>The MIDI key/controller number of the trigger event.</p>
</section>

<section><title>midiType</title>
<p>The type of MIDI trigger: note, control, program.</p>
</section>

<section><title>midiValue</title>
<p> The same as triggerValue but has a more obvious name for
use in !controller scripts.</p>
</section>

<section><title>returnCode</title>
<p>The return code of the last ThreadEvent.
Currently used only by Prompt statements to convey the 
selected button.  0 means Ok, 1 means cancel.</p>
</section>

<section><title>sustainCount</title>
<p>Number of times the script has been notified of a sustain.</p>
</section>

<section><title>triggerNumber</title>
<p>The unique id of the trigger.  For FunctionSourceMidi this will
be a combination of the MIDI status, channel, and number.  For other
sources it will be a key code or other simple number.</p>
</section>

<section><title>triggerOffset</title>
<p>An optional extra value associated with the ranged triggers.
This will have the relative position of the trigger from the
center of the range.</p>
</section>

<section><title>triggerValue</title>
<p>An optional extra value associated with the trigger.
For MIDI triggers this will be the second byte, the note velocity
for notes or the controller value for controllers.</p>
</section>

</section> <!-- Script State -->

<section><title>Loop Sizes</title>
	
<section><title>cycleCount</title>
<p>The number of cycles in the loop.</p>
</section>

<section><title>cycleFrame</title>
<p>The current frame relative the current cycle.</p>
</section>

<section><title>cycleFrames</title>
<p>The number of frames in one cycle.</p>
</section>

<section><title>cycleNumber</title>
<p>The current cycle number, relative to the beginning of the loop.</p>
</section>

<section><title>layerCount</title>
<p>The number of layers in the current loop.  This is also
in effect the current layer number since we are always "on"
the last layer of the loop.  This does not include the number
of available redo layers.</p>
</section>

<section><title>loopCount</title>
<p>The current loop count.
This is effectively the same as the "moreLoops" parameter but
I like this name better.  This should really be an alias of moreLoops
so we can get and set it using the same name!!</p>
</section>

<section><title>loopFrame</title>
<p>The current record frame.
The value
of this variable changes automatically as the loop plays. 
You might think that setting this variable would cause the playback position to
move but this is not allowed.  Intsead you must use
the <i>Move</i> function to change the playback position.</p>
</section>

<section><title>loopFrames</title>
<p>The number of frames in the loop.</p>
</section>

<section><title>loopNumber</title>
<p>The number of the curerent loop within the track.  The first
loop number is 1 for consistency with the trigger functions
Loop1, Loop2, etc.</p>
</section>

<section><title>redoCount</title>
<p>The number of redo layers in the current loop.</p>
</section>

<section><title>subCycleNumber</title>
<p>The current subcycle number, relative to the current cycle.</p>
</section>

<section><title>subCycleFrame</title>
<p>The current frame relative the current subcycle.</p>
</section>

<section><title>subCycleFrames</title>
<p>The number of frames in one subcycle.</p>
</section>

<section><title>subCycleCount</title>
<p>The number of subCycles in a cycle.
This is actually the same as the <i>Subcycles</i> preset parameter and
can change with the preset, but we expose it as an internal variable
so it is consistent with the other loop variables.</p>
</section>

</section> <!-- Loop Sizes -->

<section><title>Loop Events</title>

<section><title>nextEvent</title>
<p>Returns the type name of the next event.  Child events are ignored
so we will skip over JumpPlayEvents.  
Now that we have this, could eliminate InReturn and InRealign.</p>
</section>

<section><title>nextEventFunction</title>
<p>Returns the function name associated with the next event.
We subclass NextEventVariableType for the getTrackValue logic.</p>
</section>

<section><title>nextLoop</title>
<p>The number of the next loop if we're in loop switch mode.
Loops are numbered from 1.  Returns zero if we're not loop switching.</p>
</section>

</section> <!-- Loop Events -->

<section><title>Loop Modes</title>

<section><title>effectiveFeedback</title>
<p>The value of the feedback currently being applied.  This
will usually be either the <i>Feedback</i> or <i>Secondary Feedback</i> 
control values depending on which is being used.
It will always be zero if we're in <i>Replace</i>, <i>Insert</i>
or another mode that does not bring forward any content from the
previous loop.</p>
</section>

<section><title>inHalfSpeed</title>
<p>True if half-speed is enabled.</p>
</section>

<section><title>inMute</title>
<p>True if playback is muted.  This usually means that we're
also in Mute mode, but if Overdub is also on, mode
will be Overdub.  Note also that this tests the isMute flag
which can be on for other reasons than being in Mute mode.</p>
</section>

<section><title>inOverdub</title>
<p>True if overdub is enabled.   Note that this doesn't necessarily
mean that the mode is overdub, only that overdub is enabled when
we fall back into Play mode.</p>
</section>

<section><title>inPause</title>
<p>True if we're in Pause or Pause mode.
This is available because the "mode" parameter is not always
set to Pause.  Once case is if Pause and Overdub are on at the same
time mode will be Overdub (I think this is the only case).</p>
</section>

<section><title>inRealign</title>
<p>True if we're realigning.  This similar to a mode, but 
it is indiciated by having a Realign event scheduled.</p>
</section>

<section><title>inReturn</title>
<p>True if we're in "return" mode.  This is a special minor mode that
happens after a loop switch with SwitchDuration=OnceReturn, 
SwitchDuration=SustainReturn, or the RetriggerOnce function.  
It is indiciated by the presence of a pending Return event.</p>
</section>

<section><title>inReverse</title>
<p>True if reverse is enabled.</p>
</section>

<section><title>isRecording</title>
<p>True any form of recording is being performed.  Note that this
does not necessarily mean you are in Record mode, you could be in 
Overdub, Multiply, Insert, etc.</p>
</section>

<section><title>mode</title>

<p>This variable will contain the name of the current major mode.
The possible values are:</p>

<ul>
<li>Confirm</li>
<li>Insert</li>
<li>Multiply</li>
<li>Mute</li>
<li>Overdub</li>
<li>Pause</li>
<li>Play</li>
<li>Record</li>
<li>Rehearse</li>
<li>RehearseRecord</li>
<li>Replace</li>
<li>Reset</li>
<li>Run</li>
<li>Stutter</li>
<li>Substitute</li>
<li>Switch</li>
<li>Synchronize</li>
<li>Threshold</li>
</ul>

</section> <!-- mode -->

<section><title>rate</title>
<p>Rate shift, expressed as a scale degree.
Same as <ref>scaleRate</ref>.</p>
</section>

<section><title>rawPitch</title>
<p>Pitch shift, expressed as a float times 1000000.</p>
</section>

<section><title>rawRate</title>
<p>Rate shift, expressed as a float times 1000000.</p>
</section>

<section><title>scalePitch</title>
<p>Pitch shift, expressed as a float times 1000000.</p>
</section>

<section><title>scaleRate</title>
<p>Rate Shift, expressed as a scale degree.
Same as <ref>rate</ref></p>
</section>

</section> <!-- Loop Modes -->

<section><title>Track State</title>

<section><title>globalMute</title>
<p>True if the track will be unmuted when Global Mute mode is over.</p>
</section>

<section><title>outSyncMaster</title>
<p>The number of the track operating as the output sync master,
-1 if there is no master.</p>
</section>

<section><title>solo</title>
<p>True if the track will be unmuted when Global Mute mode is over.</p>
</section>

<section><title>track, trackNumber</title>
<p>The number of the current track.  The first track is 1.</p>
</section>

<section><title>trackCount</title>
<p>The number of tracks configured.</p>
</section>

<section><title>trackSyncMaster</title>
<p>The number of the track operating as the track sync master,
-1 if there is no master.</p>
</section>

</section> <!-- Track State -->

<section><title>Generic Sync</title>

<p>NOTE: This is out of date as of 2.0, needs revision</p>

<section><title>basePulseFrames</title>
<p>The current number of normalized pulse frames.
Internally this is a float, here it is a long integer formatted
as the internal value times 1000.</p>
</section>

<section><title>externalPulse</title>
<p>The number of external sync pulses.</p>
<p>UPDATE: We've changed the terminology a bit, this is now
"sync loop pulses" in the code, change the variable name?</p>
</section>

<section><title>externalPulses</title>
<p>The number of external sync pulses.</p>
<p>UPDATE: We've changed the terminology a bit, this is now
"sync loop pulses" in the code, change the variable name?</p>
</section>

<section><title>syncPreRealignFrame</title>
<p>The loopFrame prior to the last Realign.</p>
</section>

<section><title>pulseFrame</title>
<p>The current location of the pulse cursor.</p>
</section>

<section><title>pulseFrames</title>
<p>The current number of rate adjusted pulse frames.</p>
</section>

<section><title>pulseLoopFrame</title>
<p>The actual Loop frame at the last pulse.  The difference between
this and PulseFrame is the amount of drift (after wrapping).</p>
</section>

<section><title>syncRecordCyclePulses</title>
<p>The number of external sync pulses counted during recording.</p>
</section>

<section><title>syncBeat</title>
<p>The current bar relative beat count.
This will be the same as syncOutBeat, syncInBeat, or syncHostBeat
depending on the SyncMode of the current track.</p>
</section>

<section><title>syncBar</title>
<p>The current bar count.
This will be the same as syncOutBar, syncInBar, or syncHostBar
depending on the SyncMode of the current track.</p>
</section>

<section><title>syncDrift</title>
<p>The current amount of drift, positive or negative.</p>
</section>

<section><title>syncDriftChecks</title>
<p>The number of sync drift checks that have been perfomed in this
loop since it was recorded.</p>
</section>

<section><title>syncRawBeat</title>
<p>The current absolute beat count.
This will be the same as syncOutRawBeat, syncInRawBeat, 
or syncHostRawBeat depending on the SyncMode of the current track.</p>
</section>

<section><title>syncRealigns</title>
<p>The number of sync drift realigns that have been perfomed in this
loop since it was recorded.</p>
</section>

<section><title>syncTempo</title>
<p>The current sync tempo.  For Sync=Out this is the tempo we calculated.
For Sync=In this is the tempo we're smoothing from the external source.
For Sync=Host this is the tempo reported by the host.</p>
</section>

</section> <!-- Generic Sync -->

<section><title>Out Sync</title>

<section><title>syncOutBar</title>
<p>The current bar count maintained by the internal clock.
This is calculated from the raw beat count, modified by the
effective beatsPerBar.</p>
</section>

<section><title>syncOutBeat</title>
<p>The current beat count maintained by the internal clock,
relative to the bar.</p>
</section>

<section><title>syncOutRawBeat</title>
<p>The current raw beat count maintained by the internal clock.
This will be zero if the internal clock is not running.</p>
</section>

<section><title>syncOutSending</title>
<p>"true" if we are currently sending MIDI clocks, "false" if not.</p>
</section>

<section><title>syncOutStarted</title>
<p>"true" if we have send a MIDI Start message, "false" if not.</p>
</section>

<section><title>syncOutStarts</title>
<p>The number of MIDI Start messages we've sent since the last
time we were stopped.</p>
</section>

<section><title>syncOutTempo</title>
<p>The tempo of the internal clock used for out sync.
This is the same value returned by "tempo" but only if the
current track is in Sync=Out or Sync=OutUserStart.</p>
</section>

</section> <!-- Out Sync -->

<section><title>MIDI Sync</title>

<section><title>syncInBar</title>
<p>The current bar count derived from the external MIDI clock.</p>
</section>

<section><title>syncInBeat</title>
<p>The current beat count derived from the external MIDI clock,
relative to the bar.</p>
</section>

<section><title>syncInRawBeat</title>
<p>The current beat count derived from the external MIDI clock.</p>
</section>

<section><title>syncInReceiving</title>
<p>True if we are currently receiving MIDI clocks.</p>
</section>

<section><title>syncInStarted</title>
<p>True if we have received a MIDI start or continue message.</p>
</section>

<section><title>syncInTempo</title>
<p>The tempo of the external MIDI clock being received.
This is the same value returned by "tempo" but only if the
current track SyncMode is In, MIDIBeat, or MIDIBar.</p>
</section>


</section> <!-- MIDI Sync -->

<section><title>Host Sync</title>

<section><title>syncHostBar</title>
<p>The current bar count given by the host.</p>
</section>

<section><title>syncHostBeat</title>
<p>The current beat count given by the host, relative to the bar.</p>
</section>

<section><title>syncHostRawBeat</title>
<p>The current beat count given by the host.</p>
</section>

<section><title>syncHostReceiving</title>
<p>True if we are currently receiving MIDI clocks from the host.
Synchronizer has always returned false here, I guess because
we make MIDI passing through the host look like MIDI In sync
rather than host sync.</p>
</section>

<section><title>syncHostStarted</title>
<p>True if we have received a MIDI start or continue message from the host.
Like syncHostReceiving we've always returned false here.</p>
</section>

<section><title>syncHostTempo</title>
<p>The tempo advertised by the plugin host.</p>
</section>

</section> <!-- Host Sync -->

<section><title>Miscellaneous</title>

<section><title>blockFrames</title>
<p>The number of frames in one audio interrupt block.</p>
</section>

<section><title>configurationDirectory</title>
<p>Base directory where Mobius configuration is saved.
Typically <i>c:\Program Files\Mobius</i> on Windows and
<i>/Library/Application Support/Mobius</i> on Mac.</p>
</section>

<section><title>installationDirectory</title>
<p>Base directory where Mobius has been installed.
Typically <i>c:\Program Files\Mobius</i> on Windows and
<i>/Applications/Mobius</i> on Mac.</p>
</section>

<section><title>noExternalAudio</title>
<p>When set disables the pass through of audio received
on the first port.  This is used in the unit tests that do their
own audio injection, and we don't want random noise comming
in from the sound card to pollute it.</p>
</section>

<section><title>sampleFrames</title>
<p>The number of frames in the last sample we played.</p>
</section>

</section> <!-- Miscellaneous -->

</section> <!-- Variables -->

</section> <!-- Reference -->

<!-- ======================================================================

  Examples

====================================================================== -->

<section><title>Examples</title>

<section><title>Sustain Scripts</title>
</section> <!-- Sustain Scripts -->

<section><title>Long Press Scripts</title>
</section> <!-- Long Press Scripts -->

</section> <!-- Examples -->

</document>
